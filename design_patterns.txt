We used the Strategy method to implement the varying versions of moves that occur, such as a move forwards or backwards in time and a push move. This was extremely helpful because we could separate the logic that determined what kind of move needed to happen from the logic that actually carried the move out, making the code in the caller cleaner and easier to understand. We also found that when we needed to implement an additional feature — in this case, a paradox — it was immediately clear what part of the code needed to change and we were able to correctly modify our PushMove class without any other functionality being impacted.
Moreover, when enumerating our moves we called these Strategy classes on a copy of the board, allowing us to see what would happen if a move was played and so employing the Strategy classes helped us increase reusability.
We used the State method in our CLI class to swap between the two players with each player having its own state and a switch to the next state being triggered upon the end of a player’s turn. In hindsight, we could have simply had “current_player” and “other_player” variables and then swapped them each turn. We found using the State pattern to be useful for conceptually separating the players but ultimately it added more complexity than was actually necessary.
We used the Memento method with similar implementation as the class example for the redo and undo functionality. Save() and restore() methods in CLI are called by the Caretaker class’ backup(), undo(), and redo(), saving and restoring a Memento instance (which holds a game turn’s information) to/from a list. The Caretaker has an index variable which keeps track of the current game state being run/displayed. Remove_branches() was helpful in removing any game saves that the player has undone after typing “next”, preventing any access to no-longer-existing game states. Although this method was incredibly helpful, many of the pointers between classes had to be reimplemented, functions in classes had to be added to help with the transfer of information (such as with game.fill_empty_board()), and only specific CLI variables were necessary to deepcopy(). It was necessary, as this appears to be the more memory conscious decision (as opposed to saving the entire CLI)
We also used the Iterator method in game.better_pieces(). It is composed of a PiecesIterable and PiecesIterator class. PieceIterator will go through the player’s pieces list and call enumerate_moves on an appropriate piece to check if the items within its list of possible moves are two-move turns or single-move terms (it checks if the second tuple item is None). The iterator then returns a number (0, 1, or 2) based on if that piece has 0 moves, only 1-move turns, or  2-move turns. Better_pieces would then take a list created by this iterator, and select the max value. This came in very helpful when determining which pieces a player could/couldn’t choose, as when better_pieces() returned 0 then we know to skip that player's turn. If a piece can only do single-move turns, but if better_pieces() == 2, the user is barred from choosing that piece as there is another that has a two-move turn. 
	A Command pattern was used as well in enumerate_possible_moves, in order to more easily apply the directional movement changes to a piece’s row, column, and board location. Information was stored in a Command object, and a loop through the directional movements called execute on all of the different Command subclasses since all had execute(). It was helpful in organization and simplifying move checks. 
